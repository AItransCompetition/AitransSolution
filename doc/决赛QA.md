- 关于调度2的cwnd（拥塞窗口）和rate（速率）初始值问题？

    系统进行正式发包前需要先与对端进行建连，因此可以第一次调度SolutionCcTrigger时，传递过来的信息是建连数据包带来的信息，所以关于cwnd和rate的初始值都可以在调一次调用SolutionCcTrigger函数时进行特判并设定。

- 初赛有些输入在决赛中找不到？

    初赛给予的输入是比较多，但是经过初赛后，我们发现一些输入是不必要的，因此在决赛中，我们对输入进行了简化，但能保证选手算法能够正常移植，如有发现必须要的参数可以联系管理员。

- 在调度2（发多快）中没有时间输入？

    因为系统是真实环境，所以当前时间只需要读取系统时间即可，我们也提供了读取决赛系统当前时间方法的案例————[决赛系统当前时间](https://github.com/AItransCompetition/AitransSolution/blob/master/solution_demo/get_time/test.cxx#L3).

- 使用trace跑出来的分数不一致？

    现在系统对TC的支持有点问题，选手可以现使用ip、server_name和client_name 3个必要参数完成算法的移植，其他参数不声明时默认使用docker镜像中的数据，不声明--network表示不限速。

- cc_infos里是什么信息？

    是在当前时刻已经收到，但还未传递给选手处理的拥塞控制信息（包括ack和lost信息）组成的链表。该链表的长度与选手算法复杂度具有一定关系，系统在等待选手算法返回时，会默认使用上一次调度的结果进行运转，而在选手算法决策期间所产生新的拥塞控制信息，会在下一次调度时传递给选手算法。
    而cc_num表示cc_infos链表的长度，可以作为选手遍历链表的上限，避免指针越界。

- client.log是什么内容？bct是什么含义？为什么bct会有负数？

    clinet.log是客户端产生的log信息，其主要信息包括BlockID、bct、BlockSize、Priority和Deadline 5列。
    这里着重强调下bct的含义——block的完成时间，因为客户端和服务端使用的时间会有差异，所以DTP做了时间同步，但可能存在误差，选手可以认为负数近似为0，即block满足deadline。

- client.log中block id不是连续的，有缺失。

    决赛系统的block id使用规则是：从5开始，每次加4。

- 看demo是比赛调度1（发那个包）的内容改成了发block吗？

    并没有，调度1还是和初赛一致，调度对象只会有不同block的信息，决策结果虽然是block的id，但系统只会发该block划分出来的一个包，如果该block没有发完，那么下次选手调度仍然可以接触到该block的信息。